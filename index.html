<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scavenger Hunt - Live Location Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
        }
        
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff41;
            min-width: 250px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .header {
            color: #00ff41;
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .stats {
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .contestant-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .contestant-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 3px 0;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .contestant-item:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        
        .contestant-name {
            font-weight: bold;
            color: #00ff41;
        }
        
        .contestant-stats {
            color: #ccc;
            font-size: 11px;
        }
        
        .contestant-inactive {
            opacity: 0.6;
            border-left: 3px solid #ff4444;
        }
        
        .contestant-stale {
            opacity: 0.8;
            border-left: 3px solid #ff9500;
        }
        
        .controls {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #00ff41;
            z-index: 1000;
            width: 200px;
        }
        
        .control-btn {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: #00cc35;
        }
        
        .refresh-control {
            position: absolute;
            top: 20px;
            right: calc(10% + 100px);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #00ff41;
            z-index: 1000;
        }
        
        .refresh-control label {
            color: #00ff41;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }
        
        .refresh-control select {
            background: #000;
            color: #00ff41;
            border: 1px solid #00ff41;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .refresh-control select:focus {
            outline: none;
            border-color: #00cc35;
        }
        
        .video-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff41;
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            width: 200px;
            height: 130px; /* Includes header + 16:9 video */
        }
        
        .video-panel-header {
            background: rgba(0, 255, 65, 0.2);
            color: #00ff41;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #00ff41;
            height: 18px;
        }
        
        .video-panel-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        
        .video-panel-close {
            background: none;
            border: none;
            color: #00ff41;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .video-panel-close:hover {
            background: rgba(255, 68, 68, 0.3);
            color: #ff4444;
            border-radius: 2px;
        }
        
        .video-panel-content {
            position: relative;
            width: 100%;
            height: calc(100% - 20px); /* Subtract header height */
        }
        
        .video-panel-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #00ff41;
            font-size: 12px;
            z-index: 1000;
        }
        
        .loading {
            color: #ff9500;
        }
        
        .error {
            color: #ff0000;
        }
        
        .success {
            color: #00ff41;
        }
        
        .leaflet-popup-content-wrapper {
            background: #000 !important;
            color: #fff !important;
            border: 2px solid #00ff41 !important;
            border-radius: 8px !important;
        }
        
        .leaflet-popup-content {
            color: #fff !important;
        }
        
        .popup-content {
            padding: 10px;
        }
        
        .popup-name {
            color: #00ff41;
            font-weight: bold;
            font-size: 14px;
        }
        
        .popup-stats {
            margin-top: 5px;
            font-size: 12px;
        }
        
        .leaflet-popup-tip {
            background: #000 !important;
            border: 1px solid #00ff41 !important;
        }
        
        /* Custom marker styles */
        .marker {
            background: #00ff41;
            border: 2px solid #000;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .marker:hover {
            transform: scale(1.5);
        }
        
        .marker.high-score {
            background: #ffff00;
            width: 16px;
            height: 16px;
        }
        
        .marker.top-score {
            background: #ff4500;
            width: 20px;
            height: 20px;
        }
        
        .overlay-panel {
            position: absolute;
            bottom: 90px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            width: 200px;
            height: 120px;
        }
        
        .overlay-header {
            background: rgba(0, 255, 65, 0.2);
            color: #00ff41;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid #00ff41;
        }
        
        .overlay-iframe {
            width: 100%;
            height: calc(100% - 32px);
            border: none;
            display: block;
        }
        
        .search-panel {
            position: absolute;
            top: 330px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #00ff41;
            z-index: 1000;
            width: 200px;
        }
        
        .search-input {
            width: calc(100% - 16px);
            padding: 8px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff41;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .search-input::placeholder {
            color: #888;
        }
        
        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 5px;
        }
        
        .search-result {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .search-result:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        
        .search-result-name {
            color: #00ff41;
            font-weight: bold;
        }
        
        .search-result-details {
            color: #ccc;
            font-size: 11px;
        }
        
        /* Priority marker styles and animations */
        .priority-marker {
            z-index: 1000 !important;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Override Leaflet marker pane z-index for hot zones */
        .leaflet-marker-pane .priority-marker {
            z-index: 1000 !important;
        }
        
        /* Context menu styles */
        .context-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 8px 0;
            z-index: 2000;
            min-width: 200px;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
        }
        
        .context-menu-item {
            padding: 10px 15px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #333;
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        .context-menu-item:hover {
            background: #00ff41;
            color: #000;
        }
        
        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: none;
            color: #666;
        }
        
        /* Hot zone alert banner */
        .hotzone-alert {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff4500, #ff6500);
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            border: 3px solid #fff;
            box-shadow: 0 4px 20px rgba(255, 69, 0, 0.6);
            z-index: 2000;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            animation: alertPulse 2s infinite;
            display: none;
            max-width: 400px;
            text-align: center;
        }
        
        .hotzone-alert:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 25px rgba(255, 69, 0, 0.8);
        }
        
        .hotzone-alert .fire-icon {
            font-size: 20px;
            margin-right: 8px;
            animation: fireFlicker 1s infinite alternate;
        }
        
        @keyframes alertPulse {
            0%, 100% { box-shadow: 0 4px 20px rgba(255, 69, 0, 0.6); }
            50% { box-shadow: 0 4px 30px rgba(255, 69, 0, 1); }
        }
        
        @keyframes fireFlicker {
            0% { transform: rotate(-2deg) scale(1); }
            100% { transform: rotate(2deg) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="hotzone-alert" class="hotzone-alert">
        <span class="fire-icon">🔥</span>
        <span id="alert-text">Hot Zone Detected!</span>
    </div>
    
    <div id="context-menu" class="context-menu">
        <div class="context-menu-item" onclick="copyCoordinates()">📋 Copy Coordinates</div>
        <div class="context-menu-item" onclick="navigateToLocation()">🧭 Navigate Here</div>
        <div class="context-menu-item" onclick="addWaypoint()">📍 Add Waypoint</div>
        <div class="context-menu-item" onclick="registerRfidLocation()">🏷️ Register RFID Location</div>
        <div class="context-menu-item" onclick="measureFromHere()">📏 Measure Distance</div>
        <div class="context-menu-item" onclick="centerMapHere()">🎯 Center Map Here</div>
        <div class="context-menu-item" onclick="searchNearby()">🔍 Search Nearby</div>
    </div>
    
    <div id="rfid-context-menu" class="context-menu">
        <div class="context-menu-item" onclick="copyCoordinates()">📋 Copy Coordinates</div>
        <div class="context-menu-item" onclick="navigateToLocation()">🧭 Navigate Here</div>
        <div class="context-menu-item" onclick="centerMapHere()">🎯 Center Map Here</div>
        <div class="context-menu-item" id="delete-rfid-item" onclick="deleteRfidLocation()" style="color: #ff4444;">🗑️ Delete RFID</div>
    </div>
    
    <div id="contestant-context-menu" class="context-menu">
        <div class="context-menu-item" onclick="openContestantStream()">📺 Stream</div>
        <div class="context-menu-item" onclick="showContestantCrumbs()">🍞 Crumbs</div>
        <div class="context-menu-item" onclick="copyCoordinates()">📋 Copy Coordinates</div>
        <div class="context-menu-item" onclick="navigateToLocation()">🧭 Navigate Here</div>
        <div class="context-menu-item" onclick="centerMapHere()">🎯 Center Map Here</div>
    </div>
    
    <div class="refresh-control">
        <label for="refresh-rate">Refresh:</label>
        <select id="refresh-rate" onchange="updateRefreshRate()">
            <option value="5">5 sec</option>
            <option value="15">15 sec</option>
            <option value="30">30 sec</option>
            <option value="60">1 min</option>
            <option value="300">5 min</option>
            <option value="0">Off</option>
        </select>
    </div>
    
    <div class="controls">
        <button class="control-btn" onclick="toggleAutoRefresh()">Auto Refresh: ON</button>
        <button class="control-btn" onclick="refreshData()">Refresh Now</button>
        <button class="control-btn" onclick="fitToMarkers()">Fit All</button>
        <button class="control-btn" onclick="toggleGuessAnalysis()">Guess Analysis: OFF</button>
        <button class="control-btn" onclick="toggleRfidLocations()">Show RFID Locations</button>
        <button class="control-btn" onclick="refreshRfidData()" style="display: none;" id="refresh-rfid-btn">Refresh RFID Data</button>
        <button class="control-btn" onclick="clearBreadcrumbs()" id="clear-breadcrumbs-btn">Clear Breadcrumbs</button>
        <button class="control-btn" onclick="closeAllVideoPanels()" id="close-videos-btn">Close All Videos</button>
    </div>
    
    <div class="search-panel">
        <input 
            type="text" 
            class="search-input" 
            id="search-input"
            placeholder="Search live streamers, places, or RFID #..."
            oninput="handleSearch()"
        >
        <div class="search-results" id="search-results"></div>
    </div>
    
    <div class="info-panel">
        <div class="header">Live Streamer Data</div>
        <div class="stats" id="stats">
            <div class="stat-row">
                <span>GPS Status:</span>
                <span id="gps-status">--</span>
            </div>
            <div class="stat-row">
                <span>Total Live Streamers:</span>
                <span id="total-count">--</span>
            </div>
            <div class="stat-row">
                <span>Top Score:</span>
                <span id="top-score">--</span>
            </div>
            <div class="stat-row">
                <span>Current RFID:</span>
                <span id="current-location">--</span>
            </div>
            <div class="stat-row">
                <span>Last Update:</span>
                <span id="last-update">--</span>
            </div>
            <div class="stat-row">
                <span>Austin, TX Time:</span>
                <span id="texas-time">--</span>
            </div>
            <div class="stat-row">
                <span>Local Time:</span>
                <span id="local-time">--</span>
            </div>
        </div>
        
        <div class="contestant-list" id="contestant-list">
            <div style="color: #666; text-align: center;">Loading live streamers...</div>
        </div>
    </div>
    
    <div class="status" id="status">
        <span class="loading">Initializing map...</span>
    </div>
    
    <div class="overlay-panel">
        <div class="overlay-header">DariusIRL Stream Overlay</div>
        <iframe 
            class="overlay-iframe" 
            src="https://cxhunt-production.up.railway.app/overlay/dariusirl"
            title="DariusIRL Stream Overlay"
            allowfullscreen>
        </iframe>
    </div>
    
    <!-- Video panels will be dynamically created here -->

    <script>
        // Configuration
        const API_URL = 'https://viewerapi.iceposeidon.com/contestant.locations';
        const AUSTIN_BOUNDS = [
            [30.00663812735884, -98.16060123756967], // Southwest [lat, lng]
            [30.84173613293179, -97.19187951067062]  // Northeast [lat, lng]
        ];
        const AUSTIN_CENTER = [30.27037770663356, -97.74381171256353]; // [lat, lng]
        
        // Global variables
        let map;
        let contestants = [];
        let markers = [];
        let autoRefresh = true;
        let refreshInterval;
        let locationCache = new Map(); // Cache last known locations
        let gpsState = 'unknown'; // 'on', 'off', 'unknown'
        let lastGpsChangeTime = null;
        let viewerGuesses = new Map(); // Cache viewer guess data
        let guessAnalysis = {
            hotZones: [],
            recentGuesses: [],
            successPatterns: []
        };
        let contestantActivity = new Map(); // Track RFID scan activity over time
        let channelIcons = new Map(); // Cache Kick profile pictures
        
        // Supabase Configuration
        const SUPABASE_URL = 'https://dcvonodgixvjrcsdfnat.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRjdm9ub2RnaXh2anJjc2RmbmF0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyMTg4MTksImV4cCI6MjA3MDc5NDgxOX0.BkxHN2MOKFzkuO0xNSRXcuKysloJ9diQ3Unw6Szt3VE';
        let supabase;
        let databaseEnabled = false;
        
        // GPS detection constants
        const GPS_OFF_THRESHOLD = 0.0001; // If all contestants within this distance, GPS is likely off
        const FALLBACK_COORDS = [30.24753599760347, -97.71820629756418]; // The coordinate everyone gets when GPS is off
        
        // Supabase Database Functions
        async function loadRfidLocationsFromDB() {
            if (!databaseEnabled) return false;
            
            try {
                const { data, error } = await supabase
                    .from('rfid_locations')
                    .select('*')
                    .order('rfid_number');
                
                if (error) throw error;
                
                // Convert to existing format
                rfidLocations.clear();
                data.forEach(location => {
                    rfidLocations.set(location.rfid_number, {
                        lat: parseFloat(location.lat),
                        lng: parseFloat(location.lng),
                        confirmed: location.confirmed,
                        guessCount: location.guess_count,
                        rfidId: location.rfid_number,
                        manuallyRegistered: location.discovery_method === 'manual',
                        autoRegistered: location.discovery_method === 'auto',
                        discoveredBy: location.discovered_by,
                        discoveredByUser: location.discovered_by_username,
                        discoveredAt: location.discovered_at
                    });
                });
                
                console.log(`Loaded ${data.length} RFID locations from database`);
                return true;
            } catch (error) {
                console.error('Error loading RFID locations:', error);
                return false;
            }
        }
        
        async function saveRfidLocationToDB(rfidNumber, location) {
            if (!databaseEnabled || !isLeader) return false;
            
            try {
                const dbLocation = {
                    rfid_number: rfidNumber,
                    lat: location.lat,
                    lng: location.lng,
                    discovery_method: location.manuallyRegistered ? 'manual' : 
                                     location.autoRegistered ? 'auto' : 'viewer_guess',
                    discovered_by: location.discoveredBy,
                    discovered_by_username: location.discoveredByUser,
                    guess_count: location.guessCount,
                    confirmed: location.confirmed,
                    metadata: {
                        discoveredAt: location.discoveredAt
                    }
                };

                const { data, error } = await supabase
                    .from('rfid_locations')
                    .upsert([dbLocation], { 
                        onConflict: 'rfid_number',
                        ignoreDuplicates: false 
                    });

                if (error) throw error;
                
                // Log the RFID registration activity
                await logActivity('rfid_discovered', location.discoveredByUser, location.discoveredBy, rfidNumber, {
                    method: dbLocation.discovery_method,
                    coordinates: [location.lat, location.lng]
                });
                
                console.log(`Saved RFID #${rfidNumber} to database`);
                return true;
            } catch (error) {
                console.error('Error saving RFID location:', error);
                return false;
            }
        }
        
        async function updateContestantPositionsInDB(contestants) {
            if (!databaseEnabled || !isLeader) return false;
            
            try {
                const dbContestants = contestants.map(contestant => {
                    const [kickUser, displayName, lat, lng, points, rfids, isCached] = contestant;
                    return {
                        kick_username: kickUser,
                        display_name: displayName,
                        lat: parseFloat(lat),
                        lng: parseFloat(lng),
                        points: parseInt(points),
                        rfid_count: parseInt(rfids),
                        is_cached: Boolean(isCached),
                        gps_state: gpsState,
                        last_updated: new Date().toISOString()
                    };
                });

                const { data, error } = await supabase
                    .from('contestant_positions')
                    .upsert(dbContestants);

                if (error) throw error;
                console.log(`Updated ${dbContestants.length} contestant positions in database`);
                return true;
            } catch (error) {
                console.error('Error updating contestant positions:', error);
                return false;
            }
        }
        
        // Log activity for tracking
        async function logActivity(type, username, displayName, rfidNumber = null, details = {}) {
            if (!databaseEnabled || !isLeader) return;
            
            try {
                const { error } = await supabase
                    .from('activity_log')
                    .insert([{
                        activity_type: type,
                        kick_username: username,
                        display_name: displayName,
                        rfid_number: rfidNumber,
                        details: details
                    }]);

                if (error) throw error;
                console.log(`Logged activity: ${type}`);
            } catch (error) {
                console.error('Error logging activity:', error);
            }
        }
        
        function setupRealtimeSubscriptions() {
            if (!databaseEnabled) return;
            
            // Listen for new RFID discoveries
            supabase
                .channel('rfid-updates')
                .on('postgres_changes', { 
                    event: 'INSERT', 
                    schema: 'public', 
                    table: 'rfid_locations' 
                }, (payload) => {
                    console.log('New RFID discovered!', payload);
                    const location = payload.new;
                    rfidLocations.set(location.rfid_number, {
                        lat: parseFloat(location.lat),
                        lng: parseFloat(location.lng),
                        confirmed: location.confirmed,
                        guessCount: location.guess_count,
                        rfidId: location.rfid_number,
                        manuallyRegistered: location.discovery_method === 'manual',
                        autoRegistered: location.discovery_method === 'auto',
                        discoveredBy: location.discovered_by
                    });
                    
                    if (rfidMarkers.length > 0) {
                        displayRfidLocations();
                    }
                    
                    updateStatus(`🎯 New RFID #${location.rfid_number} discovered!`, 'success');
                })
                .subscribe();
        }
        
        async function initSupabase() {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                // Test connection
                const { data, error } = await supabase.from('rfid_locations').select('count').limit(1);
                if (error) throw error;
                
                databaseEnabled = true;
                updateStatus('Database connected', 'success');
                console.log('Supabase initialized successfully');
                
                // Start leader election
                startLeaderElection();
                
                // Setup real-time subscriptions
                setupRealtimeSubscriptions();
                
            } catch (error) {
                console.warn('Database unavailable, using localStorage fallback:', error);
                updateStatus('Using local storage (database offline)', 'loading');
                databaseEnabled = false;
            }
        }
        
        // Initialize map
        async function initMap() {
            // Initialize Leaflet map
            map = L.map('map').setView(AUSTIN_CENTER, 12);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Set max bounds
            map.setMaxBounds(AUSTIN_BOUNDS);
            
            updateStatus('Map loaded', 'success');
            
            // Initialize database
            await initSupabase();
            
            // Load RFID data (from database or localStorage fallback)
            if (databaseEnabled) {
                await loadRfidLocationsFromDB();
            } else {
                loadRfidCache();
            }
            
            // Setup context menu
            setupContextMenu();
            
            loadContestants();
            
            // Start auto-refresh with current rate
            if (autoRefresh && currentRefreshRate > 0) {
                refreshInterval = setInterval(loadContestants, currentRefreshRate * 1000);
            }
        }
        
        // Detect GPS state based on location clustering
        function detectGpsState(contestants) {
            if (contestants.length === 0) return 'unknown';
            
            // Check if everyone is at the exact same location (GPS off)
            const firstLocation = [contestants[0][2], contestants[0][3]];
            const allSameLocation = contestants.every(contestant => 
                Math.abs(contestant[2] - firstLocation[0]) < GPS_OFF_THRESHOLD &&
                Math.abs(contestant[3] - firstLocation[1]) < GPS_OFF_THRESHOLD
            );
            
            // Check if everyone is at the known fallback coordinates
            const allAtFallback = Math.abs(firstLocation[0] - FALLBACK_COORDS[0]) < GPS_OFF_THRESHOLD &&
                                Math.abs(firstLocation[1] - FALLBACK_COORDS[1]) < GPS_OFF_THRESHOLD;
            
            if (allSameLocation && allAtFallback) {
                return 'off';
            } else if (allSameLocation) {
                return 'clustered'; // Everyone at same spot, but not fallback coords
            } else {
                return 'on';
            }
        }
        
        // Update location cache with current data
        function updateLocationCache(contestants) {
            const currentGpsState = detectGpsState(contestants);
            
            // Only cache locations when GPS is on
            if (currentGpsState === 'on') {
                contestants.forEach(contestant => {
                    const [kickUser, displayName, lat, lng, points, rfids] = contestant;
                    const key = kickUser;
                    
                    // Store location with timestamp
                    locationCache.set(key, {
                        lat,
                        lng,
                        timestamp: Date.now(),
                        displayName,
                        points,
                        rfids
                    });
                });
            }
            
            // Track GPS state changes
            if (currentGpsState !== gpsState) {
                console.log(`GPS state changed: ${gpsState} -> ${currentGpsState}`);
                const previousState = gpsState;
                gpsState = currentGpsState;
                lastGpsChangeTime = new Date();
                
                // Show notification of state change
                if (previousState !== 'unknown') {
                    const message = currentGpsState === 'off' ? 
                        '📍 GPS tracking disabled by Ice' : 
                        '📍 GPS tracking enabled by Ice';
                    updateStatus(message, currentGpsState === 'off' ? 'error' : 'success');
                    
                    // Log GPS state change
                    logActivity('gps_state_change', 'system', 'Ice Poseidon', null, {
                        previous_state: previousState,
                        new_state: currentGpsState,
                        timestamp: new Date().toISOString()
                    });
                }
            }
        }
        
        // Get display data (live or cached)
        // Track contestant RFID activity over time
        function trackContestantActivity(contestants) {
            const currentTime = Date.now();
            
            // Find the current highest RFID count across all contestants
            const currentMaxRfids = Math.max(...contestants.map(c => c[5]), 0);
            
            contestants.forEach(contestant => {
                const [kickUser, displayName, lat, lng, points, rfids] = contestant;
                const key = kickUser;
                
                // Auto-register RFID location if someone reached a new high RFID count
                if (rfids > highestRfidSeen && rfids === currentMaxRfids) {
                    autoRegisterRfidLocation(rfids, lat, lng, displayName, kickUser);
                    highestRfidSeen = rfids;
                }
                
                if (contestantActivity.has(key)) {
                    const activity = contestantActivity.get(key);
                    
                    // Check if RFID count increased (new scan)
                    if (rfids > activity.lastRfidCount) {
                        activity.lastRfidScan = currentTime;
                        activity.lastRfidCount = rfids;
                        activity.totalScans = rfids;
                    }
                } else {
                    // New contestant
                    contestantActivity.set(key, {
                        displayName,
                        lastRfidScan: currentTime,
                        lastRfidCount: rfids,
                        totalScans: rfids,
                        firstSeen: new Date(currentTime)
                    });
                    
                    // Log new contestant discovery (only if not already logged in last hour)
                    if (databaseEnabled) {
                        // Check if we've already logged this contestant recently to avoid duplicates
                        supabase.from('activity_log')
                            .select('id')
                            .eq('activity_type', 'new_contestant')
                            .eq('kick_username', kickUser)
                            .gte('created_at', new Date(Date.now() - 60*60*1000).toISOString()) // Last hour
                            .limit(1)
                            .then(({ data, error }) => {
                                if (!error && (!data || data.length === 0)) {
                                    // No recent log entry, safe to log as new contestant
                                    logActivity('new_contestant', kickUser, displayName, null, {
                                        points: points,
                                        rfid_count: rfids,
                                        coordinates: [lat, lng],
                                        first_seen: new Date(currentTime).toISOString()
                                    });
                                }
                            });
                    }
                }
            });
        }
        
        function autoRegisterRfidLocation(rfidNumber, lat, lng, discovererName, kickUser) {
            // Don't register if coordinates are invalid or at fallback location
            const FALLBACK_COORDS = [30.24753599760347, -97.71820629756418];
            const GPS_OFF_THRESHOLD = 0.0001;
            
            if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                console.log(`Invalid coordinates for RFID #${rfidNumber} auto-registration`);
                return;
            }
            
            // Skip if at fallback coordinates (GPS off)
            if (Math.abs(lat - FALLBACK_COORDS[0]) < GPS_OFF_THRESHOLD && 
                Math.abs(lng - FALLBACK_COORDS[1]) < GPS_OFF_THRESHOLD) {
                console.log(`Skipping RFID #${rfidNumber} auto-registration - GPS appears to be off`);
                return;
            }
            
            // Skip if RFID already exists (unless this is more recent)
            if (rfidLocations.has(rfidNumber)) {
                const existing = rfidLocations.get(rfidNumber);
                if (existing.autoRegistered) {
                    // Update if this is from a different location (RFIDs can move?)
                    const distance = Math.sqrt(Math.pow(existing.lat - lat, 2) + Math.pow(existing.lng - lng, 2));
                    if (distance < 0.001) { // Within ~100m, consider it the same location
                        return;
                    }
                }
            }
            
            // Create auto-registered RFID location
            const rfidLocation = {
                lat: lat,
                lng: lng,
                confirmed: true,
                guessCount: 1,
                rfidId: rfidNumber,
                autoRegistered: true,
                discoveredBy: discovererName,
                discoveredByUser: kickUser,
                discoveredAt: new Date().toISOString()
            };
            
            rfidLocations.set(rfidNumber, rfidLocation);
            
            // Save to database (with localStorage fallback)
            if (databaseEnabled) {
                saveRfidLocationToDB(rfidNumber, rfidLocation);
            } else {
                saveRfidCache();
            }
            
            // Update display if RFID markers are shown
            if (rfidMarkers.length > 0) {
                displayRfidLocations();
            }
            
            // Show notification
            console.log(`🎯 Auto-registered RFID #${rfidNumber} discovered by ${discovererName} at ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
            updateStatus(`🎯 RFID #${rfidNumber} auto-registered! Discovered by ${discovererName}`, 'success');
        }
        
        function getContestantActivityStatus(kickUser) {
            const activity = contestantActivity.get(kickUser);
            if (!activity) return { status: 'unknown', hoursInactive: 0 };
            
            const hoursSinceLastScan = (Date.now() - activity.lastRfidScan) / (1000 * 60 * 60);
            
            if (hoursSinceLastScan > 24) {
                return { 
                    status: 'inactive', 
                    hoursInactive: Math.floor(hoursSinceLastScan) 
                };
            } else if (hoursSinceLastScan > 12) {
                return { 
                    status: 'stale', 
                    hoursInactive: Math.floor(hoursSinceLastScan) 
                };
            } else {
                return { 
                    status: 'active', 
                    hoursInactive: Math.floor(hoursSinceLastScan) 
                };
            }
        }

        function getDisplayData(contestants) {
            const currentGpsState = detectGpsState(contestants);
            
            if (currentGpsState === 'on') {
                // GPS is on, use live data
                return {
                    data: contestants,
                    isLive: true,
                    gpsState: currentGpsState
                };
            } else {
                // GPS is off, use cached locations where available
                const mixedData = contestants.map(contestant => {
                    const [kickUser, displayName, lat, lng, points, rfids] = contestant;
                    const cached = locationCache.get(kickUser);
                    
                    if (cached && (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000)) { // Use cache for up to 24 hours
                        // Use cached location but current points/rfids
                        return [kickUser, displayName, cached.lat, cached.lng, points, rfids, true]; // true = using cached location
                    } else {
                        // No cache available, use current (fallback) data
                        return [kickUser, displayName, lat, lng, points, rfids, false]; // false = using live (fallback) data
                    }
                });
                
                return {
                    data: mixedData,
                    isLive: false,
                    gpsState: currentGpsState
                };
            }
        }
        
        // Load contestant data from API
        async function loadContestants() {
            try {
                updateStatus('Loading live streamer data...', 'loading');
                
                const response = await fetch(API_URL, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'application/json, text/plain, */*',
                        'Referer': 'https://event.iceposeidon.com/',
                        'Origin': 'https://event.iceposeidon.com'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const rawData = await response.json();
                
                console.log('Raw API data:', rawData);
                console.log('Number of contestants:', rawData.length);
                
                // Update cache and detect GPS state
                updateLocationCache(rawData);
                
                // Track contestant activity
                trackContestantActivity(rawData);
                
                // Get display data (live or cached)
                const displayInfo = getDisplayData(rawData);
                contestants = displayInfo.data;
                
                console.log('Display data:', contestants.slice(0, 5));
                console.log('GPS State:', displayInfo.gpsState);
                console.log('Using live data:', displayInfo.isLive);
                
                await updateMap();
                updateStats();
                updateContestantList();
                
                // Save contestant positions to database
                if (databaseEnabled && contestants.length > 0) {
                    updateContestantPositionsInDB(contestants);
                    
                    // Log location history for each contestant (with intelligent filtering)
                    contestants.forEach(contestant => {
                        logLocationHistory(contestant);
                    });
                }
                
                // Update status with GPS state info
                const statusMsg = displayInfo.isLive ? 
                    `Loaded ${contestants.length} live streamers (GPS ON)` :
                    `Loaded ${contestants.length} live streamers (GPS OFF - using cached locations)`;
                
                updateStatus(statusMsg, displayInfo.isLive ? 'success' : 'loading');
                
            } catch (error) {
                console.error('Error loading live streamers:', error);
                updateStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Update map markers
        async function updateMap() {
            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            
            console.log('Creating markers for', contestants.length, 'contestants');
            
            // Group contestants by location to handle clusters
            const locationGroups = {};
            contestants.forEach((contestant) => {
                const [kickUser, displayName, lat, lng, points, rfids, isCached] = contestant;
                const locationKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                
                if (!locationGroups[locationKey]) {
                    locationGroups[locationKey] = [];
                }
                locationGroups[locationKey].push(contestant);
            });
            
            console.log('Location clusters:', Object.keys(locationGroups).length);
            
            // Create markers for each location cluster
            for (const [locationKey, contestantGroup] of Object.entries(locationGroups)) {
                const [lat, lng] = locationKey.split(',').map(Number);
                const groupSize = contestantGroup.length;
                
                console.log(`Cluster at (${lat}, ${lng}) with ${groupSize} contestants`);
                
                // Validate coordinates
                if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                    console.warn(`Invalid coordinates for cluster:`, { lat, lng });
                    return;
                }
                
                // Calculate cluster stats
                const totalPoints = contestantGroup.reduce((sum, c) => sum + c[4], 0);
                const highestScore = Math.max(...contestantGroup.map(c => c[4]));
                const topContestant = contestantGroup.find(c => c[4] === highestScore);
                const cachedCount = contestantGroup.filter(c => c[6] === true).length; // Count cached locations
                const liveCount = groupSize - cachedCount;
                
                // Create custom icon based on cluster size, top score, and GPS state
                let iconSize = [15 + (groupSize * 2), 15 + (groupSize * 2)]; // Bigger for more people
                let iconColor = '#00ff41';
                let borderStyle = '2px solid #000';
                
                // Color based on score
                if (highestScore > 10000) {
                    iconColor = '#ff4500';
                } else if (highestScore > 1000) {
                    iconColor = '#ffff00';
                }
                
                // Border style based on GPS state
                if (gpsState === 'off') {
                    borderStyle = '3px dashed #ff0000'; // Red dashed border when GPS is off
                } else if (cachedCount > 0 && liveCount > 0) {
                    borderStyle = '3px dotted #ff9500'; // Orange dotted border for mixed data
                }
                
                // Create custom icon with profile picture (for single contestants) or count (for clusters)
                let customIcon;
                if (groupSize === 1) {
                    // Single contestant - try to use profile picture
                    const [kickUser] = contestantGroup[0];
                    const avatarUrl = await fetchKickChannelIcon(kickUser);
                    customIcon = createProfileMarkerIcon(avatarUrl, groupSize, highestScore, gpsState, cachedCount, liveCount);
                } else {
                    // Multiple contestants - use count-based icon
                    customIcon = L.divIcon({
                        html: `
                            <div style="background: ${iconColor}; border: ${borderStyle}; border-radius: 50%; width: ${iconSize[0]}px; height: ${iconSize[1]}px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: ${Math.min(12 + groupSize, 20)}px; color: #000;">
                                ${groupSize}
                            </div>
                        `,
                        className: 'custom-marker',
                        iconSize: iconSize,
                        iconAnchor: [iconSize[0]/2, iconSize[1]/2]
                    });
                }
                
                // GPS state info for popup
                let gpsStatusText = '';
                let gpsStatusColor = '#00ff41';
                
                if (gpsState === 'off') {
                    gpsStatusText = '📍 GPS OFF (using cached locations)';
                    gpsStatusColor = '#ff0000';
                } else if (gpsState === 'clustered') {
                    gpsStatusText = '📍 All contestants clustered together';
                    gpsStatusColor = '#ff9500';
                } else {
                    gpsStatusText = '📍 GPS ON (live tracking)';
                    gpsStatusColor = '#00ff41';
                }
                
                // Create popup content for cluster
                let popupContent = `
                    <div class="popup-content">
                        <div class="popup-name">${groupSize} Live Streamers at this location</div>
                        <div style="color: ${gpsStatusColor}; font-size: 12px; margin: 4px 0;">${gpsStatusText}</div>
                        <div class="popup-stats">
                            <div>Total Points: ${totalPoints.toLocaleString()}</div>
                            <div>Top Scorer: ${topContestant[1]} (${highestScore.toLocaleString()})</div>
                            <div>Location: ${lat.toFixed(6)}, ${lng.toFixed(6)}</div>
                `;
                
                if (cachedCount > 0 && liveCount > 0) {
                    popupContent += `<div style="font-size: 11px; color: #ff9500;">📡 ${liveCount} live, ${cachedCount} cached</div>`;
                } else if (cachedCount > 0) {
                    popupContent += `<div style="font-size: 11px; color: #ff0000;">📡 All locations from cache</div>`;
                }
                
                popupContent += `<hr style="margin: 8px 0;">`;
                
                // Add top 5 contestants to popup
                const sortedGroup = [...contestantGroup].sort((a, b) => b[4] - a[4]);
                sortedGroup.slice(0, 5).forEach(contestant => {
                    const [kickUser, displayName, cLat, cLng, points, rfids, isCached] = contestant;
                    const cacheIndicator = isCached ? ' 📡' : '';
                    popupContent += `
                        <div style="margin: 2px 0;">
                            <strong>${displayName}</strong>: ${points.toLocaleString()} pts, ${rfids} RFIDs${cacheIndicator}
                        </div>
                    `;
                });
                
                if (groupSize > 5) {
                    popupContent += `<div style="margin-top: 5px; font-style: italic;">...and ${groupSize - 5} more</div>`;
                }
                
                popupContent += `
                        </div>
                    </div>
                `;
                
                // Create and add marker with click and context menu handlers
                const marker = L.marker([lat, lng], { icon: customIcon })
                    .bindPopup(popupContent)
                    .on('click', function() {
                        // For clusters, pick the top contestant by points; for single, use that one
                        const topContestant = contestantGroup.reduce((top, current) => 
                            current[4] > top[4] ? current : top);
                        const [kickUser, displayName] = topContestant;
                        openStreamVideo(kickUser, displayName);
                    })
                    .on('contextmenu', function(e) {
                        e.originalEvent.preventDefault();
                        e.originalEvent.stopPropagation();
                        
                        // For clusters, pick the top contestant; for single, use that one
                        const topContestant = contestantGroup.reduce((top, current) => 
                            current[4] > top[4] ? current : top);
                        const [kickUser, displayName] = topContestant;
                        
                        // Store contestant context data
                        contextMenuData.lat = lat;
                        contextMenuData.lng = lng;
                        contextMenuData.isContestantMarker = true;
                        contextMenuData.kickUsername = kickUser;
                        contextMenuData.displayName = displayName;
                        contextMenuData.rfidId = null;
                        contextMenuData.isRfidMarker = false;
                        
                        showContestantContextMenu(e.originalEvent.pageX, e.originalEvent.pageY);
                    })
                    .addTo(map);
                
                markers.push(marker);
            }
        }
        
        // Update statistics
        function updateStats() {
            const totalCount = contestants.length;
            const topScore = Math.max(...contestants.map(c => c[4]), 0);
            const topRfids = Math.max(...contestants.map(c => c[5]), 0);
            const currentLocation = Math.min(topRfids + 1, 50); // Next location they're working on (max 50)
            const lastUpdate = new Date().toLocaleTimeString();
            const cachedCount = contestants.filter(c => c[6] === true).length;
            
            document.getElementById('total-count').textContent = totalCount;
            document.getElementById('top-score').textContent = topScore.toLocaleString();
            document.getElementById('current-location').textContent = `${currentLocation}/50`;
            document.getElementById('last-update').textContent = lastUpdate;
            
            // Update time displays
            const now = new Date();
            const texasTime = now.toLocaleTimeString('en-US', { 
                timeZone: 'America/Chicago', 
                hour12: true,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const localTime = now.toLocaleTimeString('en-US', {
                hour12: true,
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            document.getElementById('texas-time').textContent = texasTime;
            document.getElementById('local-time').textContent = localTime;
            
            // Update GPS status if element exists
            const gpsStatusEl = document.getElementById('gps-status');
            if (gpsStatusEl) {
                let statusText = '';
                let statusColor = '#00ff41';
                
                if (gpsState === 'off') {
                    statusText = `GPS OFF (${cachedCount} cached)`;
                    statusColor = '#ff0000';
                } else if (gpsState === 'clustered') {
                    statusText = 'GPS ON (clustered)';
                    statusColor = '#ff9500';
                } else if (gpsState === 'on') {
                    statusText = 'GPS ON (live)';
                    statusColor = '#00ff41';
                } else {
                    statusText = 'GPS Unknown';
                    statusColor = '#666';
                }
                
                gpsStatusEl.textContent = statusText;
                gpsStatusEl.style.color = statusColor;
            }
        }
        
        // Update contestant list
        function updateContestantList() {
            const listEl = document.getElementById('contestant-list');
            
            // Sort by RFID count first, then by points
            const sorted = [...contestants].sort((a, b) => {
                const [, , , , aPoints, aRfids] = a;
                const [, , , , bPoints, bRfids] = b;
                
                // Primary sort: RFID count (descending)
                if (bRfids !== aRfids) {
                    return bRfids - aRfids;
                }
                
                // Secondary sort: Points (descending) 
                return bPoints - aPoints;
            });
            
            const html = sorted.map(contestant => {
                const [kickUser, displayName, lat, lng, points, rfids] = contestant;
                const activityStatus = getContestantActivityStatus(kickUser);
                
                // Style based on activity status
                let statusClass = '';
                let statusText = '';
                let statusColor = '#ccc';
                
                if (activityStatus.status === 'inactive') {
                    statusClass = 'contestant-inactive';
                    statusText = `💤 ${activityStatus.hoursInactive}h inactive`;
                    statusColor = '#ff4444';
                } else if (activityStatus.status === 'stale') {
                    statusClass = 'contestant-stale';
                    statusText = `⏰ ${activityStatus.hoursInactive}h ago`;
                    statusColor = '#ff9500';
                } else if (activityStatus.hoursInactive > 0) {
                    statusText = `✅ ${activityStatus.hoursInactive}h ago`;
                    statusColor = '#00ff41';
                }
                
                return `
                    <div class="contestant-item ${statusClass}" onclick="focusContestant(${lng}, ${lat})">
                        <div class="contestant-name">${displayName}</div>
                        <div class="contestant-stats">
                            ${points.toLocaleString()} pts • ${rfids} RFIDs
                            ${statusText ? `<br><span style="color: ${statusColor}; font-size: 10px;">${statusText}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            listEl.innerHTML = html;
        }
        
        // Focus on specific contestant
        function focusContestant(lng, lat) {
            map.setView([lat, lng], 16);
        }
        
        // Fit map to show all markers
        function fitToMarkers() {
            if (contestants.length === 0) return;
            
            const bounds = L.latLngBounds();
            contestants.forEach(contestant => {
                bounds.extend([contestant[2], contestant[3]]); // lat, lng
            });
            
            map.fitBounds(bounds, { padding: [20, 20] });
        }
        
        // Toggle auto-refresh
        let currentRefreshRate = 5; // Default 5 seconds
        
        function updateRefreshRate() {
            const select = document.getElementById('refresh-rate');
            const newRate = parseInt(select.value);
            currentRefreshRate = newRate;
            
            // Clear existing interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
            
            // Update auto refresh button
            const autoRefreshBtn = document.querySelector('.controls button');
            if (newRate === 0) {
                autoRefresh = false;
                autoRefreshBtn.textContent = 'Auto Refresh: OFF';
            } else {
                autoRefresh = true;
                autoRefreshBtn.textContent = `Auto Refresh: ON (${newRate < 60 ? newRate + 's' : Math.floor(newRate/60) + 'm'})`;
                refreshInterval = setInterval(loadContestants, newRate * 1000);
            }
        }
        
        function toggleAutoRefresh() {
            const select = document.getElementById('refresh-rate');
            
            if (autoRefresh && currentRefreshRate > 0) {
                // Turn off
                select.value = '0';
                updateRefreshRate();
            } else {
                // Turn on with default rate
                select.value = '5';
                updateRefreshRate();
            }
        }
        
        // Manual refresh
        function refreshData() {
            loadContestants();
        }
        
        // Context Menu System
        let contextMenuData = { 
            lat: 0, 
            lng: 0, 
            rfidId: null, 
            isRfidMarker: false, 
            isAutoRegistered: false,
            isContestantMarker: false,
            kickUsername: null,
            displayName: null
        };
        let waypoints = [];
        let measurementLine = null;
        let measurementStart = null;
        
        function setupContextMenu() {
            const contextMenu = document.getElementById('context-menu');
            
            // Right-click on map to show context menu
            map.on('contextmenu', function(e) {
                e.originalEvent.preventDefault();
                
                contextMenuData.lat = e.latlng.lat;
                contextMenuData.lng = e.latlng.lng;
                contextMenuData.rfidId = null;
                contextMenuData.isRfidMarker = false;
                contextMenuData.isAutoRegistered = false;
                contextMenuData.isContestantMarker = false;
                contextMenuData.kickUsername = null;
                contextMenuData.displayName = null;
                
                // Position context menu at cursor
                contextMenu.style.left = e.originalEvent.pageX + 'px';
                contextMenu.style.top = e.originalEvent.pageY + 'px';
                contextMenu.style.display = 'block';
            });
            
            // Hide context menu on map click or outside click
            map.on('click', hideContextMenu);
            document.addEventListener('click', function(e) {
                const rfidContextMenu = document.getElementById('rfid-context-menu');
                const contestantContextMenu = document.getElementById('contestant-context-menu');
                if (!contextMenu.contains(e.target) && 
                    !rfidContextMenu.contains(e.target) && 
                    !contestantContextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });
            
            // Prevent map events when clicking context menus
            contextMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            const rfidContextMenu = document.getElementById('rfid-context-menu');
            rfidContextMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            const contestantContextMenu = document.getElementById('contestant-context-menu');
            contestantContextMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
            document.getElementById('rfid-context-menu').style.display = 'none';
            document.getElementById('contestant-context-menu').style.display = 'none';
        }
        
        function showContestantContextMenu(pageX, pageY) {
            const contestantContextMenu = document.getElementById('contestant-context-menu');
            
            // Position and show menu
            contestantContextMenu.style.left = pageX + 'px';
            contestantContextMenu.style.top = pageY + 'px';
            contestantContextMenu.style.display = 'block';
        }
        
        function openContestantStream() {
            if (contextMenuData.isContestantMarker && contextMenuData.kickUsername) {
                openStreamVideo(contextMenuData.kickUsername, contextMenuData.displayName);
            }
            hideContextMenu();
        }
        
        async function showContestantCrumbs() {
            if (contextMenuData.isContestantMarker && contextMenuData.kickUsername) {
                await showBreadcrumbTrail(contextMenuData.kickUsername, contextMenuData.displayName);
            }
            hideContextMenu();
        }
        
        function showRfidContextMenu(pageX, pageY) {
            const rfidContextMenu = document.getElementById('rfid-context-menu');
            const deleteItem = document.getElementById('delete-rfid-item');
            
            // Only show delete option for auto-registered RFIDs
            if (contextMenuData.isAutoRegistered) {
                deleteItem.style.display = 'block';
            } else {
                deleteItem.style.display = 'none';
            }
            
            // Position and show menu
            rfidContextMenu.style.left = pageX + 'px';
            rfidContextMenu.style.top = pageY + 'px';
            rfidContextMenu.style.display = 'block';
        }
        
        async function deleteRfidLocation() {
            if (!isLeader) {
                updateStatus('RFID deletion only available to data collector', 'error');
                hideContextMenu();
                return;
            }
            
            if (!contextMenuData.isRfidMarker || !contextMenuData.rfidId) {
                hideContextMenu();
                return;
            }
            
            const rfidId = contextMenuData.rfidId;
            const location = rfidLocations.get(rfidId);
            
            if (!location || !location.autoRegistered) {
                updateStatus('Can only delete auto-registered RFIDs', 'error');
                hideContextMenu();
                return;
            }
            
            const confirmed = confirm(`Delete auto-registered RFID #${rfidId}?\n\nThis will remove it from the map and database.`);
            if (!confirmed) {
                hideContextMenu();
                return;
            }
            
            try {
                // Remove from local map
                rfidLocations.delete(rfidId);
                
                // Remove from database
                if (databaseEnabled) {
                    const { error } = await supabase
                        .from('rfid_locations')
                        .delete()
                        .eq('rfid_number', rfidId);
                    
                    if (error) throw error;
                    console.log(`Deleted RFID #${rfidId} from database`);
                } else {
                    // Remove from localStorage
                    saveRfidCache();
                }
                
                // Refresh display
                if (rfidMarkers.length > 0) {
                    displayRfidLocations();
                }
                
                updateStatus(`Deleted RFID #${rfidId}`, 'success');
                
            } catch (error) {
                console.error('Error deleting RFID:', error);
                updateStatus('Error deleting RFID location', 'error');
            }
            
            hideContextMenu();
        }
        
        function copyCoordinates() {
            const coords = `${contextMenuData.lat.toFixed(6)}, ${contextMenuData.lng.toFixed(6)}`;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(coords).then(() => {
                    updateStatus(`Coordinates copied: ${coords}`, 'success');
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = coords;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                updateStatus(`Coordinates copied: ${coords}`, 'success');
            }
            hideContextMenu();
        }
        
        function navigateToLocation() {
            const lat = contextMenuData.lat.toFixed(6);
            const lng = contextMenuData.lng.toFixed(6);
            
            // Create navigation URLs for different platforms
            const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
            const appleMapsUrl = `maps://maps.google.com/maps?daddr=${lat},${lng}&amp;ll=`;
            const universalUrl = `geo:${lat},${lng}`;
            
            // Detect user's platform/device
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
            const isAndroid = /android/i.test(userAgent);
            const isMobile = isIOS || isAndroid;
            
            let navigationUrl = googleMapsUrl; // Default to Google Maps
            
            if (isMobile) {
                if (isIOS) {
                    // iOS: Try Apple Maps first, fallback to Google Maps
                    navigationUrl = appleMapsUrl;
                } else if (isAndroid) {
                    // Android: Use geo: URI which opens default maps app
                    navigationUrl = universalUrl;
                }
            }
            
            try {
                // Try to open the navigation URL
                const newWindow = window.open(navigationUrl, '_blank');
                
                // If popup blocker prevents opening, show fallback options
                if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                    showNavigationOptions(lat, lng);
                } else {
                    updateStatus(`Opening navigation to ${lat}, ${lng}`, 'success');
                }
                
            } catch (error) {
                console.log('Navigation failed:', error);
                showNavigationOptions(lat, lng);
            }
            
            hideContextMenu();
        }
        
        function showNavigationOptions(lat, lng) {
            // Fallback: Show multiple navigation options
            const options = [
                { name: 'Google Maps', url: `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}` },
                { name: 'Apple Maps (iOS)', url: `maps://maps.google.com/maps?daddr=${lat},${lng}&amp;ll=` },
                { name: 'Generic Maps App', url: `geo:${lat},${lng}` }
            ];
            
            let message = `Navigate to ${lat}, ${lng}:\n\n`;
            options.forEach((option, index) => {
                message += `${index + 1}. ${option.name}\n`;
            });
            message += '\nChoose an option:';
            
            const choice = prompt(message + '\nEnter number (1-3):');
            const choiceIndex = parseInt(choice) - 1;
            
            if (choiceIndex >= 0 && choiceIndex < options.length) {
                try {
                    window.open(options[choiceIndex].url, '_blank');
                    updateStatus(`Opening ${options[choiceIndex].name}`, 'success');
                } catch (error) {
                    updateStatus('Unable to open navigation app', 'error');
                }
            }
        }
        
        function addWaypoint() {
            const waypoint = L.marker([contextMenuData.lat, contextMenuData.lng], {
                icon: L.divIcon({
                    html: `
                        <div style="
                            background: #2196F3; 
                            border: 3px solid #fff; 
                            border-radius: 50%; 
                            width: 20px; 
                            height: 20px; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            color: #fff;
                            font-weight: bold;
                            font-size: 12px;
                        ">
                            ${waypoints.length + 1}
                        </div>
                    `,
                    className: 'waypoint-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).addTo(map);
            
            waypoint.bindPopup(`
                <div class="popup-content">
                    <div class="popup-name">📍 Waypoint ${waypoints.length + 1}</div>
                    <div class="popup-stats">
                        <div>Coordinates: ${contextMenuData.lat.toFixed(4)}, ${contextMenuData.lng.toFixed(4)}</div>
                        <button onclick="removeWaypoint(${waypoints.length})" style="margin-top: 5px; padding: 5px 10px; background: #ff4444; color: #fff; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
                    </div>
                </div>
            `);
            
            waypoints.push(waypoint);
            updateStatus(`Waypoint ${waypoints.length} added`, 'success');
            hideContextMenu();
        }
        
        function removeWaypoint(index) {
            if (waypoints[index]) {
                map.removeLayer(waypoints[index]);
                waypoints.splice(index, 1);
                updateStatus('Waypoint removed', 'success');
            }
        }
        
        function measureFromHere() {
            if (measurementLine) {
                map.removeLayer(measurementLine);
            }
            
            measurementStart = [contextMenuData.lat, contextMenuData.lng];
            
            const startMarker = L.marker(measurementStart, {
                icon: L.divIcon({
                    html: '📏',
                    className: 'measurement-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).addTo(map);
            
            updateStatus('Click another point to measure distance', 'loading');
            
            // Listen for next click to complete measurement
            map.once('click', function(e) {
                const endPoint = [e.latlng.lat, e.latlng.lng];
                const distance = map.distance(measurementStart, endPoint);
                
                measurementLine = L.polyline([measurementStart, endPoint], {
                    color: '#ff4500',
                    weight: 3,
                    dashArray: '10, 10'
                }).addTo(map);
                
                const endMarker = L.marker(endPoint, {
                    icon: L.divIcon({
                        html: '🎯',
                        className: 'measurement-marker',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);
                
                const distanceText = distance < 1000 ? 
                    `${distance.toFixed(0)}m` : 
                    `${(distance/1000).toFixed(2)}km`;
                
                updateStatus(`Distance: ${distanceText}`, 'success');
                
                // Clean up markers after 10 seconds
                setTimeout(() => {
                    map.removeLayer(startMarker);
                    map.removeLayer(endMarker);
                    if (measurementLine) map.removeLayer(measurementLine);
                }, 10000);
            });
            
            hideContextMenu();
        }
        
        function centerMapHere() {
            map.setView([contextMenuData.lat, contextMenuData.lng], Math.max(map.getZoom(), 15));
            updateStatus('Map centered', 'success');
            hideContextMenu();
        }
        
        function searchNearby() {
            const coords = `${contextMenuData.lat.toFixed(4)}, ${contextMenuData.lng.toFixed(4)}`;
            document.getElementById('search-input').value = coords;
            performSearch(coords);
            hideContextMenu();
        }
        
        function registerRfidLocation() {
            hideContextMenu();
            
            if (!isLeader) {
                updateStatus('RFID registration only available to data collector', 'error');
                return;
            }
            
            const rfidId = prompt('Enter RFID number (1-50):');
            
            if (rfidId === null) {
                // User cancelled
                return;
            }
            
            const rfidNumber = parseInt(rfidId);
            
            // Validate input
            if (isNaN(rfidNumber) || rfidNumber < 1 || rfidNumber > 50) {
                updateStatus('Invalid RFID number. Please enter a number between 1-50.', 'error');
                return;
            }
            
            // Check if RFID already exists
            if (rfidLocations.has(rfidNumber)) {
                const confirmOverwrite = confirm(`RFID #${rfidNumber} already exists at this location. Overwrite?`);
                if (!confirmOverwrite) {
                    return;
                }
            }
            
            // Create the RFID location object
            const rfidLocation = {
                lat: contextMenuData.lat,
                lng: contextMenuData.lng,
                confirmed: true, // Manual registration is always confirmed
                guessCount: 1, // Mark as manually registered
                rfidId: rfidNumber,
                manuallyRegistered: true
            };
            
            // Add to our locations map
            rfidLocations.set(rfidNumber, rfidLocation);
            
            // Save to database (with localStorage fallback)
            if (databaseEnabled) {
                saveRfidLocationToDB(rfidNumber, rfidLocation);
            } else {
                saveRfidCache();
            }
            
            // If RFID locations are currently being shown, update the display
            if (rfidMarkers.length > 0) {
                displayRfidLocations();
            }
            
            // Center map on the new RFID location and show it
            map.setView([contextMenuData.lat, contextMenuData.lng], Math.max(map.getZoom(), 16));
            
            updateStatus(`RFID #${rfidNumber} registered successfully!`, 'success');
        }
        
        // Update status message
        function updateStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `<span class="${type}">${message}</span>`;
        }
        
        // Search functionality
        let searchTimeout;
        
        function handleSearch() {
            const query = document.getElementById('search-input').value.trim();
            const resultsEl = document.getElementById('search-results');
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            if (query.length < 2) {
                resultsEl.innerHTML = '';
                return;
            }
            
            // Debounce search
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        }
        
        async function performSearch(query) {
            const resultsEl = document.getElementById('search-results');
            resultsEl.innerHTML = '<div style="color: #888; padding: 8px;">Searching...</div>';
            
            const results = [];
            
            // Search contestants
            const contestantMatches = contestants.filter(contestant => 
                contestant[1].toLowerCase().includes(query.toLowerCase()) // displayName
            ).slice(0, 5); // Limit to top 5
            
            contestantMatches.forEach(contestant => {
                const [kickUser, displayName, lat, lng, points, rfids] = contestant;
                results.push({
                    type: 'live_streamer',
                    name: displayName,
                    details: `${points.toLocaleString()} pts • ${rfids} RFIDs`,
                    lat: lat,
                    lng: lng
                });
            });
            
            // Search RFID locations by number
            const rfidNumber = parseInt(query);
            if (!isNaN(rfidNumber) && rfidNumber > 0 && rfidNumber <= 50) {
                const rfidLocation = rfidLocations.get(rfidNumber);
                if (rfidLocation) {
                    results.push({
                        type: 'rfid',
                        name: `RFID #${rfidNumber}`,
                        details: `${rfidLocation.confirmed ? 'Confirmed' : 'Estimated'} location • ${rfidLocation.guessCount} guesses`,
                        lat: rfidLocation.lat,
                        lng: rfidLocation.lng
                    });
                } else if (rfidLocations.size > 0) {
                    // Offer to search for this RFID if we have other RFIDs but not this one
                    results.push({
                        type: 'rfid_search',
                        name: `Search for RFID #${rfidNumber}`,
                        details: 'Click to discover location from viewer guesses',
                        lat: null,
                        lng: null,
                        rfidId: rfidNumber
                    });
                }
            }
            
            // Search places using Nominatim (OpenStreetMap geocoding)
            try {
                if (query.length > 3) { // Only search places for longer queries
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=3&q=${encodeURIComponent(query + ' Austin Texas')}`);
                    const places = await response.json();
                    
                    places.forEach(place => {
                        // Only show places within Austin area
                        const lat = parseFloat(place.lat);
                        const lng = parseFloat(place.lon);
                        if (lat >= 30.0 && lat <= 30.9 && lng >= -98.2 && lng <= -97.1) {
                            results.push({
                                type: 'place',
                                name: place.display_name.split(',')[0], // Just the main part
                                details: `📍 ${place.type} in Austin`,
                                lat: lat,
                                lng: lng
                            });
                        }
                    });
                }
            } catch (error) {
                console.log('Place search failed:', error);
            }
            
            // Display results
            if (results.length === 0) {
                resultsEl.innerHTML = '<div style="color: #888; padding: 8px;">No results found</div>';
            } else {
                resultsEl.innerHTML = results.map(result => {
                    if (result.type === 'rfid_search') {
                        return `
                            <div class="search-result" onclick="searchSpecificRfid(${result.rfidId})">
                                <div class="search-result-name">${result.name}</div>
                                <div class="search-result-details">${result.details}</div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="search-result" onclick="goToLocation(${result.lat}, ${result.lng})">
                                <div class="search-result-name">${result.name}</div>
                                <div class="search-result-details">${result.details}</div>
                            </div>
                        `;
                    }
                }).join('');
            }
        }
        
        function goToLocation(lat, lng) {
            map.setView([lat, lng], 16);
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').innerHTML = '';
        }
        
        async function searchSpecificRfid(rfidId) {
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').innerHTML = '';
            
            updateStatus(`Searching for RFID #${rfidId}...`, 'loading');
            
            try {
                const guesses = await fetchViewerGuesses(rfidId);
                if (guesses && guesses.length > 0) {
                    const location = findRfidLocationFromGuesses(guesses, rfidId);
                    if (location) {
                        rfidLocations.set(rfidId, location);
                        
                        // Save to cache after discovery
                        saveRfidCache();
                        
                        // Show the location on map
                        displayRfidLocations();
                        map.setView([location.lat, location.lng], 16);
                        
                        updateStatus(`Found RFID #${rfidId} location!`, 'success');
                    } else {
                        updateStatus(`Could not determine location for RFID #${rfidId}`, 'error');
                    }
                } else {
                    updateStatus(`No viewer guesses found for RFID #${rfidId}`, 'error');
                }
            } catch (error) {
                updateStatus(`Error searching for RFID #${rfidId}`, 'error');
            }
        }
        
        // Kick Channel Icon Functions
        async function fetchKickChannelIcon(kickUsername) {
            if (channelIcons.has(kickUsername)) {
                return channelIcons.get(kickUsername);
            }
            
            try {
                // Try to fetch Kick channel data
                const response = await fetch(`https://kick.com/api/v1/channels/${kickUsername}`, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const channelData = await response.json();
                    let avatarUrl = null;
                    
                    // Extract profile picture URL
                    if (channelData.user && channelData.user.profile_pic) {
                        avatarUrl = channelData.user.profile_pic;
                    } else if (channelData.profile_pic) {
                        avatarUrl = channelData.profile_pic;
                    }
                    
                    // Ensure HTTPS and cache result
                    if (avatarUrl) {
                        if (avatarUrl.startsWith('//')) {
                            avatarUrl = 'https:' + avatarUrl;
                        } else if (avatarUrl.startsWith('/')) {
                            avatarUrl = 'https://kick.com' + avatarUrl;
                        }
                        
                        channelIcons.set(kickUsername, avatarUrl);
                        return avatarUrl;
                    }
                }
            } catch (error) {
                console.log(`Failed to fetch icon for ${kickUsername}:`, error);
            }
            
            // Fallback: cache null to avoid repeated failed requests
            channelIcons.set(kickUsername, null);
            return null;
        }
        
        function createProfileMarkerIcon(avatarUrl, groupSize, highestScore, gpsState, cachedCount, liveCount) {
            const iconSize = Math.max(30, 20 + (groupSize * 3)); // Minimum 30px, scales with group
            
            // Border style based on GPS state
            let borderStyle = '3px solid #00ff41';
            if (gpsState === 'off') {
                borderStyle = '3px dashed #ff0000';
            } else if (cachedCount > 0 && liveCount > 0) {
                borderStyle = '3px dotted #ff9500';
            }
            
            // Background color based on score
            let backgroundColor = '#00ff41';
            if (highestScore > 10000) {
                backgroundColor = '#ff4500';
            } else if (highestScore > 1000) {
                backgroundColor = '#ffff00';
            }
            
            const html = avatarUrl ? `
                <div style="
                    width: ${iconSize}px; 
                    height: ${iconSize}px; 
                    border-radius: 50%; 
                    border: ${borderStyle}; 
                    background: ${backgroundColor};
                    padding: 2px;
                    cursor: pointer;
                    position: relative;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                ">
                    <img src="${avatarUrl}" 
                         style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;" 
                         onerror="this.style.display='none'; this.parentElement.innerHTML='👤';">
                    ${groupSize > 1 ? `<div style="
                        position: absolute; 
                        bottom: -5px; 
                        right: -5px; 
                        background: #000; 
                        color: #fff; 
                        border-radius: 50%; 
                        width: 18px; 
                        height: 18px; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        font-size: 10px; 
                        font-weight: bold;
                        border: 1px solid #00ff41;
                    ">${groupSize}</div>` : ''}
                </div>
            ` : `
                <div style="
                    background: ${backgroundColor}; 
                    border: ${borderStyle}; 
                    border-radius: 50%; 
                    width: ${iconSize}px; 
                    height: ${iconSize}px; 
                    cursor: pointer; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    font-weight: bold; 
                    font-size: ${Math.min(12 + groupSize, 20)}px; 
                    color: #000;
                ">
                    ${groupSize > 1 ? groupSize : '👤'}
                </div>
            `;
            
            return L.divIcon({
                html: html,
                className: 'profile-marker',
                iconSize: [iconSize, iconSize],
                iconAnchor: [iconSize/2, iconSize/2]
            });
        }
        
        // Viewer Guess Analysis Engine
        async function fetchViewerGuesses(rfidId) {
            try {
                const response = await fetch(`https://viewerapi.iceposeidon.com/viewer.guesses.rfid.${rfidId}`);
                if (response.ok) {
                    const data = await response.json();
                    return data.viewer_guesses || [];
                }
            } catch (error) {
                console.log(`Failed to fetch guesses for RFID ${rfidId}:`, error);
            }
            return [];
        }
        
        async function analyzeViewerGuesses() {
            const topRfids = Math.max(...contestants.map(c => c[5]), 0);
            const currentRfid = Math.min(topRfids + 1, 50);
            
            // Fetch guesses for current and recent RFIDs
            const rfidsToAnalyze = [currentRfid, Math.max(1, currentRfid - 1), Math.max(1, currentRfid - 2)];
            const allGuesses = [];
            
            for (const rfidId of rfidsToAnalyze) {
                const guesses = await fetchViewerGuesses(rfidId);
                guesses.forEach(guess => {
                    allGuesses.push({
                        rfid: rfidId,
                        username: guess[0],
                        lat: guess[1],
                        lng: guess[2],
                        timestamp: new Date(guess[3])
                    });
                });
            }
            
            // Proximity Analysis - find guess clusters
            const hotZones = findGuessHotZones(allGuesses);
            
            // Time Analysis - recent guess velocity
            const recentGuesses = allGuesses.filter(g => 
                (Date.now() - g.timestamp.getTime()) < 3600000 // Last hour
            );
            
            guessAnalysis = {
                hotZones,
                recentGuesses,
                totalGuesses: allGuesses.length,
                currentRfid
            };
            
            console.log('Guess Analysis:', guessAnalysis);
            return guessAnalysis;
        }
        
        function findGuessHotZones(guesses) {
            const zones = [];
            const processed = new Set();
            const CLUSTER_DISTANCE = 0.001; // ~100 meters
            
            guesses.forEach((guess, i) => {
                if (processed.has(i)) return;
                
                const cluster = [guess];
                processed.add(i);
                
                // Find nearby guesses
                guesses.forEach((otherGuess, j) => {
                    if (i !== j && !processed.has(j)) {
                        const distance = Math.sqrt(
                            Math.pow(guess.lat - otherGuess.lat, 2) + 
                            Math.pow(guess.lng - otherGuess.lng, 2)
                        );
                        
                        if (distance < CLUSTER_DISTANCE) {
                            cluster.push(otherGuess);
                            processed.add(j);
                        }
                    }
                });
                
                if (cluster.length >= 3) { // Minimum 3 guesses to be a "hot zone"
                    const centerLat = cluster.reduce((sum, g) => sum + g.lat, 0) / cluster.length;
                    const centerLng = cluster.reduce((sum, g) => sum + g.lng, 0) / cluster.length;
                    
                    zones.push({
                        lat: centerLat,
                        lng: centerLng,
                        count: cluster.length,
                        rfids: [...new Set(cluster.map(g => g.rfid))],
                        recentActivity: cluster.filter(g => 
                            (Date.now() - g.timestamp.getTime()) < 1800000 // Last 30 minutes
                        ).length
                    });
                }
            });
            
            return zones.sort((a, b) => b.count - a.count);
        }
        
        // Guess Analysis UI
        let showGuessAnalysis = false;
        let guessMarkers = [];
        let rfidMarkers = [];
        let rfidLocations = new Map(); // Map of RFID ID to {lat, lng, confirmed, guessCount}
        let highestRfidSeen = 0; // Track the highest RFID count globally
        
        function toggleGuessAnalysis() {
            showGuessAnalysis = !showGuessAnalysis;
            const btn = event.target;
            
            if (showGuessAnalysis) {
                btn.textContent = 'Guess Analysis: ON';
                btn.style.background = '#ff9500';
                analyzeViewerGuesses().then(displayGuessHotZones);
            } else {
                btn.textContent = 'Guess Analysis: OFF';
                btn.style.background = '#00ff41';
                clearGuessMarkers();
            }
        }
        
        function clearGuessMarkers() {
            guessMarkers.forEach(marker => map.removeLayer(marker));
            guessMarkers = [];
            hideHotZoneAlert(); // Hide alert when clearing all markers
        }
        
        // Hot zone alert management
        let currentAlertZone = null;
        
        // RFID Location Management with localStorage caching
        const RFID_CACHE_KEY = 'teamdarius_rfid_locations';
        const RFID_CACHE_EXPIRY = 'teamdarius_rfid_cache_time';
        const CACHE_DURATION = 6 * 60 * 60 * 1000; // 6 hours in milliseconds
        
        function loadRfidCache() {
            try {
                const cacheTime = localStorage.getItem(RFID_CACHE_EXPIRY);
                const cachedData = localStorage.getItem(RFID_CACHE_KEY);
                
                if (cacheTime && cachedData) {
                    const timeDiff = Date.now() - parseInt(cacheTime);
                    if (timeDiff < CACHE_DURATION) {
                        // Cache is still valid
                        const locationData = JSON.parse(cachedData);
                        locationData.forEach(([rfidId, location]) => {
                            rfidLocations.set(rfidId, location);
                        });
                        console.log(`Loaded ${rfidLocations.size} RFID locations from cache`);
                        return true;
                    }
                }
            } catch (error) {
                console.log('Error loading RFID cache:', error);
            }
            return false;
        }
        
        function saveRfidCache() {
            try {
                const locationData = Array.from(rfidLocations.entries());
                localStorage.setItem(RFID_CACHE_KEY, JSON.stringify(locationData));
                localStorage.setItem(RFID_CACHE_EXPIRY, Date.now().toString());
                console.log(`Saved ${rfidLocations.size} RFID locations to cache`);
            } catch (error) {
                console.log('Error saving RFID cache:', error);
            }
        }
        
        async function discoverRfidLocations(forceRefresh = false) {
            // Try to load from cache first unless forcing refresh
            if (!forceRefresh && loadRfidCache()) {
                displayRfidLocations();
                return;
            }
            
            console.log('Discovering RFID locations from viewer guesses...');
            const originalSize = rfidLocations.size;
            
            // Check RFIDs 1-50 (adjust range as needed)
            for (let rfidId = 1; rfidId <= 50; rfidId++) {
                // Skip if we already have this RFID and not forcing refresh
                if (!forceRefresh && rfidLocations.has(rfidId)) {
                    continue;
                }
                
                try {
                    const guesses = await fetchViewerGuesses(rfidId);
                    if (guesses && guesses.length > 0) {
                        // Cluster guesses to find the most likely RFID location
                        const location = findRfidLocationFromGuesses(guesses, rfidId);
                        if (location) {
                            rfidLocations.set(rfidId, location);
                        }
                    }
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    // Silent fail for individual RFID lookups
                    console.log(`No data for RFID ${rfidId}`);
                }
            }
            
            const newLocations = rfidLocations.size - originalSize;
            console.log(`Discovered ${newLocations} new RFID locations (${rfidLocations.size} total)`);
            
            // Save to cache after discovery
            saveRfidCache();
            displayRfidLocations();
        }
        
        function findRfidLocationFromGuesses(guesses, rfidId) {
            if (!guesses || guesses.length === 0) return null;
            
            // Group guesses by proximity (within ~50 meters)
            const clusters = [];
            const proximityThreshold = 0.0005; // roughly 50 meters in degrees
            
            guesses.forEach(guess => {
                const lat = parseFloat(guess[0]);
                const lng = parseFloat(guess[1]);
                
                if (isNaN(lat) || isNaN(lng)) return;
                
                // Find existing cluster within threshold
                let foundCluster = clusters.find(cluster => {
                    const distance = Math.sqrt(
                        Math.pow(cluster.centerLat - lat, 2) + 
                        Math.pow(cluster.centerLng - lng, 2)
                    );
                    return distance < proximityThreshold;
                });
                
                if (foundCluster) {
                    foundCluster.guesses.push([lat, lng]);
                    // Update center (weighted average)
                    const totalGuesses = foundCluster.guesses.length;
                    foundCluster.centerLat = foundCluster.guesses.reduce((sum, g) => sum + g[0], 0) / totalGuesses;
                    foundCluster.centerLng = foundCluster.guesses.reduce((sum, g) => sum + g[1], 0) / totalGuesses;
                } else {
                    clusters.push({
                        centerLat: lat,
                        centerLng: lng,
                        guesses: [[lat, lng]]
                    });
                }
            });
            
            if (clusters.length === 0) return null;
            
            // Return the cluster with the most guesses (most confident location)
            const bestCluster = clusters.reduce((max, cluster) => 
                cluster.guesses.length > max.guesses.length ? cluster : max
            );
            
            // Only consider it confirmed if there are multiple guesses clustered together
            const confirmed = bestCluster.guesses.length >= 3;
            
            return {
                lat: bestCluster.centerLat,
                lng: bestCluster.centerLng,
                confirmed: confirmed,
                guessCount: bestCluster.guesses.length,
                rfidId: rfidId
            };
        }
        
        function showHotZoneAlert(zone) {
            const alert = document.getElementById('hotzone-alert');
            const alertText = document.getElementById('alert-text');
            
            currentAlertZone = zone;
            alertText.textContent = `🔥 HOT ZONE: ${zone.recentActivity} recent guesses - CLICK TO VIEW!`;
            
            // Show the alert
            alert.style.display = 'block';
            
            // Add click handler to center map on hot zone
            alert.onclick = () => {
                map.setView([zone.lat, zone.lng], Math.max(map.getZoom(), 16));
                // Optional: Open popup for the zone marker
                const hotZoneMarker = guessMarkers.find(marker => {
                    const pos = marker.getLatLng();
                    return Math.abs(pos.lat - zone.lat) < 0.001 && Math.abs(pos.lng - zone.lng) < 0.001;
                });
                if (hotZoneMarker) {
                    hotZoneMarker.openPopup();
                }
            };
        }
        
        function hideHotZoneAlert() {
            const alert = document.getElementById('hotzone-alert');
            alert.style.display = 'none';
            currentAlertZone = null;
        }
        
        function displayRfidLocations() {
            // Clear existing RFID markers
            clearRfidMarkers();
            
            rfidLocations.forEach((location, rfidId) => {
                const confirmedIcon = L.divIcon({
                    html: `
                        <div style="
                            background: ${location.manuallyRegistered ? '#2196F3' : (location.autoRegistered ? '#9C27B0' : (location.confirmed ? '#4CAF50' : '#FF9800'))}; 
                            border: 3px solid #fff; 
                            border-radius: 15px; 
                            width: 30px; 
                            height: 30px; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            font-weight: bold; 
                            font-size: 12px; 
                            color: #fff;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                        ">
                            ${rfidId}
                        </div>
                    `,
                    className: 'rfid-location-marker',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
                
                const popupContent = `
                    <div class="popup-content">
                        <div class="popup-name">📍 RFID Location #${rfidId}</div>
                        <div class="popup-stats">
                            <div>Status: ${location.manuallyRegistered ? 'Manually Registered' : (location.autoRegistered ? 'Auto-Registered' : (location.confirmed ? 'Confirmed' : 'Estimated'))}</div>
                            <div>${location.manuallyRegistered ? 'Manually added by user' : (location.autoRegistered ? `First discovered by ${location.discoveredBy}` : `Based on ${location.guessCount} viewer guesses`)}</div>
                            ${location.autoRegistered ? `<div style="color: #9C27B0; font-size: 11px;">Auto-registered when first scanned</div>` : ''}
                            <div>Coordinates: ${location.lat.toFixed(4)}, ${location.lng.toFixed(4)}</div>
                        </div>
                    </div>
                `;
                
                const marker = L.marker([location.lat, location.lng], { 
                    icon: confirmedIcon,
                    pane: 'markerPane'
                })
                    .bindPopup(popupContent)
                    .on('contextmenu', function(e) {
                        e.originalEvent.preventDefault();
                        e.originalEvent.stopPropagation();
                        
                        // Store RFID context data
                        contextMenuData.lat = location.lat;
                        contextMenuData.lng = location.lng;
                        contextMenuData.rfidId = rfidId;
                        contextMenuData.isRfidMarker = true;
                        contextMenuData.isAutoRegistered = location.autoRegistered;
                        
                        showRfidContextMenu(e.originalEvent.pageX, e.originalEvent.pageY);
                    })
                    .addTo(map);
                
                rfidMarkers.push(marker);
            });
        }
        
        function clearRfidMarkers() {
            rfidMarkers.forEach(marker => map.removeLayer(marker));
            rfidMarkers = [];
        }
        
        function toggleRfidLocations() {
            const btn = event.target;
            const refreshBtn = document.getElementById('refresh-rfid-btn');
            
            if (rfidMarkers.length > 0) {
                // Hide RFID locations
                clearRfidMarkers();
                btn.textContent = 'Show RFID Locations';
                refreshBtn.style.display = 'none';
            } else {
                // Show RFID locations
                if (rfidLocations.size === 0) {
                    updateStatus('Loading RFID locations...', 'loading');
                    discoverRfidLocations().then(() => {
                        const message = rfidLocations.size > 0 ? 
                            `Loaded ${rfidLocations.size} RFID locations from ${loadRfidCache() ? 'cache' : 'live data'}` :
                            'No RFID locations found yet';
                        updateStatus(message, rfidLocations.size > 0 ? 'success' : 'loading');
                    });
                } else {
                    displayRfidLocations();
                }
                btn.textContent = 'Hide RFID Locations';
                refreshBtn.style.display = 'inline-block';
            }
        }
        
        async function refreshRfidData() {
            updateStatus('Refreshing RFID locations...', 'loading');
            
            try {
                if (databaseEnabled) {
                    // Refresh from database
                    await loadRfidLocationsFromDB();
                } else {
                    // Fallback: refresh from API discovery
                    await discoverRfidLocations(true);
                }
                
                const message = `Refreshed! Found ${rfidLocations.size} RFID locations`;
                updateStatus(message, 'success');
                
                // Update display if RFID markers are shown
                if (rfidMarkers.length > 0) {
                    displayRfidLocations();
                }
            } catch (error) {
                console.error('Error refreshing RFID data:', error);
                updateStatus('Error refreshing RFID data', 'error');
            }
        }
        
        function clearRfidCache() {
            try {
                localStorage.removeItem(RFID_CACHE_KEY);
                localStorage.removeItem(RFID_CACHE_EXPIRY);
                rfidLocations.clear();
                clearRfidMarkers();
                console.log('RFID cache cleared');
            } catch (error) {
                console.log('Error clearing RFID cache:', error);
            }
        }
        
        function displayGuessHotZones() {
            clearGuessMarkers();
            
            // Check for definitive hot zones (>10 recent activity) to show alert
            const definitiveZones = guessAnalysis.hotZones.filter(zone => zone.recentActivity > 10);
            
            if (definitiveZones.length > 0) {
                // Show alert for the most active zone
                const mostActiveZone = definitiveZones.reduce((max, zone) => 
                    zone.recentActivity > max.recentActivity ? zone : max
                );
                showHotZoneAlert(mostActiveZone);
            } else {
                hideHotZoneAlert();
            }
            
            guessAnalysis.hotZones.forEach(zone => {
                // Create hot zone marker with enhanced visibility
                const heatColor = zone.recentActivity > 5 ? '#ff4500' : '#ffff00';
                const isDefinitive = zone.recentActivity > 10;
                const blinkAnimation = isDefinitive ? 'animation: blink 1.5s infinite;' : '';
                const pulseAnimation = zone.recentActivity > 5 ? 'animation: pulse 2s infinite;' : '';
                const animation = isDefinitive ? blinkAnimation : pulseAnimation;
                
                const hotZoneIcon = L.divIcon({
                    html: `
                        <div style="
                            background: ${heatColor}; 
                            border: 4px solid #fff; 
                            border-radius: 50%; 
                            width: ${isDefinitive ? 40 : 30}px; 
                            height: ${isDefinitive ? 40 : 30}px; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            font-weight: bold; 
                            font-size: ${isDefinitive ? 20 : 16}px; 
                            color: #000;
                            box-shadow: 0 0 15px rgba(255, 69, 0, 0.8);
                            z-index: 1000;
                            position: relative;
                            ${animation}
                        ">
                            🔥
                        </div>
                    `,
                    className: 'guess-hotzone-marker priority-marker',
                    iconSize: [isDefinitive ? 40 : 30, isDefinitive ? 40 : 30],
                    iconAnchor: [isDefinitive ? 20 : 15, isDefinitive ? 20 : 15]
                });
                
                const popupContent = `
                    <div class="popup-content">
                        <div class="popup-name">🔥 Guess Hot Zone</div>
                        <div class="popup-stats">
                            <div>Total Guesses: ${zone.count}</div>
                            <div>Recent Activity: ${zone.recentActivity} (30min)</div>
                            <div>RFIDs: ${zone.rfids.join(', ')}</div>
                            <div>Coordinates: ${zone.lat.toFixed(4)}, ${zone.lng.toFixed(4)}</div>
                        </div>
                    </div>
                `;
                
                const marker = L.marker([zone.lat, zone.lng], { 
                    icon: hotZoneIcon,
                    pane: 'overlayPane'
                })
                    .bindPopup(popupContent)
                    .addTo(map);
                
                // Ensure high z-index for definitive hot zones
                if (isDefinitive) {
                    setTimeout(() => {
                        const markerElement = marker.getElement();
                        if (markerElement) {
                            markerElement.style.zIndex = '1000';
                        }
                    }, 10);
                }
                    
                guessMarkers.push(marker);
            });
            
            updateStatus(`Found ${guessAnalysis.hotZones.length} guess hot zones`, 'success');
        }
        
        // Initialize everything
        // Leader Election System
        let isLeader = false;
        let sessionId = generateSessionId();
        let heartbeatInterval;
        let leaderCheckInterval;
        
        // Location History Tracking
        let locationHistoryTimer;
        let lastLoggedPositions = new Map(); // Track last logged position per contestant
        let breadcrumbTrails = new Map(); // Store active breadcrumb trails
        let activeBreadcrumbs = [];
        
        function generateSessionId() {
            return 'dash_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        }
        
        function isDashCollector() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('dash') === 'active';
        }
        
        // Leader Election Functions
        async function tryBecomeLeader() {
            if (!databaseEnabled) {
                isLeader = isDashCollector(); // Fallback to URL parameter if DB unavailable
                updateLeaderStatus();
                return;
            }
            
            try {
                // Check current leader status
                const { data: currentLeader, error: selectError } = await supabase
                    .from('dashboard_leader')
                    .select('*')
                    .eq('id', 1)
                    .single();
                
                if (selectError) throw selectError;
                
                const now = new Date();
                const lastHeartbeat = new Date(currentLeader.last_heartbeat);
                const timeSinceHeartbeat = (now - lastHeartbeat) / 1000; // seconds
                
                // Become leader if: no current leader, heartbeat is stale (>60s), or we're the dash collector
                const shouldBecomeLeader = 
                    currentLeader.session_id === 'none' || 
                    timeSinceHeartbeat > 60 ||
                    (isDashCollector() && currentLeader.session_id !== sessionId);
                
                if (shouldBecomeLeader) {
                    const { error: updateError } = await supabase
                        .from('dashboard_leader')
                        .update({
                            session_id: sessionId,
                            client_info: {
                                isDashCollector: isDashCollector(),
                                userAgent: navigator.userAgent.substring(0, 100),
                                timestamp: now.toISOString()
                            },
                            last_heartbeat: now.toISOString()
                        })
                        .eq('id', 1);
                    
                    if (!updateError) {
                        isLeader = true;
                        console.log(`Became dashboard leader (${isDashCollector() ? 'collector' : 'public'})`);
                    }
                } else if (currentLeader.session_id === sessionId) {
                    // We're already the leader
                    isLeader = true;
                } else {
                    isLeader = false;
                }
                
            } catch (error) {
                console.error('Error in leader election:', error);
                // Fallback: dash collectors can become leader even if DB fails
                isLeader = isDashCollector();
            }
            
            updateLeaderStatus();
        }
        
        async function sendHeartbeat() {
            if (!isLeader || !databaseEnabled) return;
            
            try {
                const { error } = await supabase
                    .from('dashboard_leader')
                    .update({
                        last_heartbeat: new Date().toISOString()
                    })
                    .eq('session_id', sessionId);
                    
                if (error) {
                    console.warn('Heartbeat failed, may lose leadership:', error);
                }
            } catch (error) {
                console.error('Heartbeat error:', error);
            }
        }
        
        function updateLeaderStatus() {
            const statusEl = document.querySelector('.status');
            if (statusEl) {
                const roleText = isLeader ? 
                    (isDashCollector() ? '🎯 Data Collector' : '👑 Leader') : 
                    '👁️ Read Only';
                    
                const existingRole = statusEl.querySelector('.leader-status');
                if (existingRole) {
                    existingRole.textContent = roleText;
                } else {
                    const roleSpan = document.createElement('span');
                    roleSpan.className = 'leader-status';
                    roleSpan.textContent = roleText;
                    roleSpan.style.cssText = 'float: right; font-size: 11px; opacity: 0.8;';
                    statusEl.appendChild(roleSpan);
                }
            }
            
            // Update page title
            const titlePrefix = isLeader ? 
                (isDashCollector() ? '[COLLECTOR] ' : '[LEADER] ') : 
                '[READ-only] ';
            document.title = titlePrefix + 'Scavenger Hunt - Live Location Map';
        }
        
        function startLeaderElection() {
            // Try to become leader immediately
            tryBecomeLeader();
            
            // Set up heartbeat (every 30 seconds)
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            heartbeatInterval = setInterval(sendHeartbeat, 30000);
            
            // Check for leader changes (every 45 seconds)
            if (leaderCheckInterval) clearInterval(leaderCheckInterval);
            leaderCheckInterval = setInterval(tryBecomeLeader, 45000);
        }
        
        // Location History Functions
        async function logLocationHistory(contestant) {
            if (!databaseEnabled || !isLeader) return;
            
            const [kickUser, displayName, lat, lng, points, rfids, isCached] = contestant;
            const positionKey = `${kickUser}`;
            const currentPosition = { lat: parseFloat(lat), lng: parseFloat(lng) };
            
            // Check if this is a significant position change (>50 meters) or first log
            const lastPosition = lastLoggedPositions.get(positionKey);
            let shouldLog = false;
            
            if (!lastPosition) {
                // First time seeing this contestant
                shouldLog = true;
            } else {
                // Calculate distance from last logged position
                const distance = calculateDistance(
                    lastPosition.lat, lastPosition.lng,
                    currentPosition.lat, currentPosition.lng
                );
                
                // Log if moved >50m OR if last log was >10 minutes ago
                const timeSinceLastLog = Date.now() - lastPosition.timestamp;
                shouldLog = distance > 0.05 || timeSinceLastLog > 10 * 60 * 1000;
            }
            
            if (shouldLog) {
                try {
                    const { error } = await supabase
                        .from('location_history')
                        .insert([{
                            kick_username: kickUser,
                            display_name: displayName,
                            lat: currentPosition.lat,
                            lng: currentPosition.lng,
                            points: parseInt(points),
                            rfid_count: parseInt(rfids),
                            gps_state: gpsState,
                            is_cached: Boolean(isCached)
                        }]);

                    if (error) throw error;
                    
                    // Update last logged position
                    lastLoggedPositions.set(positionKey, {
                        ...currentPosition,
                        timestamp: Date.now()
                    });
                    
                    console.log(`Logged location history for ${kickUser}`);
                } catch (error) {
                    console.error('Error logging location history:', error);
                }
            }
        }
        
        function calculateDistance(lat1, lng1, lat2, lng2) {
            // Haversine formula for distance in kilometers
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        async function loadBreadcrumbTrail(kickUsername) {
            if (!databaseEnabled) return [];
            
            try {
                const { data, error } = await supabase
                    .from('recent_location_history')
                    .select('*')
                    .eq('kick_username', kickUsername)
                    .order('recorded_at', { ascending: true });
                    
                if (error) throw error;
                
                return data || [];
            } catch (error) {
                console.error('Error loading breadcrumb trail:', error);
                return [];
            }
        }
        
        async function showBreadcrumbTrail(kickUsername, displayName) {
            const trail = await loadBreadcrumbTrail(kickUsername);
            
            if (trail.length < 2) {
                updateStatus(`No location history found for ${displayName}`, 'error');
                return;
            }
            
            // Clear existing breadcrumbs
            clearBreadcrumbs();
            
            // Create trail polyline
            const trailCoords = trail.map(point => [point.lat, point.lng]);
            const trailLine = L.polyline(trailCoords, {
                color: '#ff6b6b',
                weight: 3,
                opacity: 0.8,
                dashArray: '10, 5'
            }).addTo(map);
            
            // Add markers for start and end points
            const startPoint = trail[0];
            const endPoint = trail[trail.length - 1];
            
            const startMarker = L.marker([startPoint.lat, startPoint.lng], {
                icon: L.divIcon({
                    html: `<div style="background: #28a745; border: 2px solid #fff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold;">S</div>`,
                    className: 'breadcrumb-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).bindPopup(`${displayName} - Trail Start<br>${new Date(startPoint.recorded_at).toLocaleString()}`).addTo(map);
            
            const endMarker = L.marker([endPoint.lat, endPoint.lng], {
                icon: L.divIcon({
                    html: `<div style="background: #dc3545; border: 2px solid #fff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold;">E</div>`,
                    className: 'breadcrumb-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).bindPopup(`${displayName} - Current Position<br>${new Date(endPoint.recorded_at).toLocaleString()}`).addTo(map);
            
            // Store breadcrumb elements for cleanup
            activeBreadcrumbs = [trailLine, startMarker, endMarker];
            
            // Fit map to trail
            map.fitBounds(trailLine.getBounds(), { padding: [20, 20] });
            
            updateStatus(`Showing ${trail.length} location points for ${displayName} over last 4 hours`, 'success');
        }
        
        function clearBreadcrumbs() {
            activeBreadcrumbs.forEach(element => {
                if (map.hasLayer(element)) {
                    map.removeLayer(element);
                }
            });
            activeBreadcrumbs = [];
        }
        
        // Multi-Panel Video System
        let activePanels = [];
        let panelIdCounter = 0;
        
        // Clockwise positioning: top(4) → right(3) → bottom(4) → left(3)
        const panelPositions = [
            // Top row (4 panels)
            { top: '10px', left: '10px' },
            { top: '10px', left: '220px' },
            { top: '10px', left: '430px' },
            { top: '10px', left: '640px' },
            // Right side (3 panels)
            { top: '150px', right: '10px' },
            { top: '290px', right: '10px' },
            { top: '430px', right: '10px' },
            // Bottom row (4 panels, right to left)
            { bottom: '10px', right: '10px' },
            { bottom: '10px', right: '220px' },
            { bottom: '10px', right: '430px' },
            { bottom: '10px', right: '640px' },
            // Left side (3 panels, bottom to top)
            { bottom: '150px', left: '10px' },
            { bottom: '290px', left: '10px' }
        ];
        
        function openStreamVideo(kickUsername, displayName) {
            if (!kickUsername) return;
            
            // Check if panel already exists for this streamer
            const existingPanel = activePanels.find(p => p.username === kickUsername);
            if (existingPanel) {
                console.log(`Panel already open for ${kickUsername}`);
                return;
            }
            
            // Close oldest panel if we're at max capacity
            if (activePanels.length >= 12) {
                closeVideoPanel(activePanels[0].id);
            }
            
            // Create new panel
            const panelId = `video-panel-${++panelIdCounter}`;
            const position = panelPositions[activePanels.length];
            
            const panel = document.createElement('div');
            panel.id = panelId;
            panel.className = 'video-panel';
            
            // Apply position
            Object.keys(position).forEach(key => {
                panel.style[key] = position[key];
            });
            
            panel.innerHTML = `
                <div class="video-panel-header">
                    <div class="video-panel-title">${displayName}</div>
                    <button class="video-panel-close" onclick="closeVideoPanel('${panelId}')">×</button>
                </div>
                <div class="video-panel-content">
                    <iframe class="video-panel-iframe" src="https://player.kick.com/${kickUsername}" allowfullscreen></iframe>
                </div>
            `;
            
            document.body.appendChild(panel);
            
            // Track panel
            activePanels.push({
                id: panelId,
                username: kickUsername,
                displayName: displayName,
                element: panel
            });
            
            console.log(`Opened panel ${activePanels.length}/12 for ${kickUsername}`);
        }
        
        function closeVideoPanel(panelId) {
            const panelIndex = activePanels.findIndex(p => p.id === panelId);
            if (panelIndex === -1) return;
            
            const panel = activePanels[panelIndex];
            
            // Remove from DOM
            panel.element.remove();
            
            // Remove from tracking
            activePanels.splice(panelIndex, 1);
            
            // Reposition remaining panels
            repositionPanels();
            
            console.log(`Closed panel for ${panel.displayName}, ${activePanels.length} panels remaining`);
        }
        
        function repositionPanels() {
            activePanels.forEach((panel, index) => {
                const position = panelPositions[index];
                
                // Clear all position styles
                panel.element.style.top = '';
                panel.element.style.right = '';
                panel.element.style.bottom = '';
                panel.element.style.left = '';
                
                // Apply new position
                Object.keys(position).forEach(key => {
                    panel.element.style[key] = position[key];
                });
            });
        }
        
        function closeAllVideoPanels() {
            while (activePanels.length > 0) {
                closeVideoPanel(activePanels[0].id);
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
        });
    </script>
</body>
</html>